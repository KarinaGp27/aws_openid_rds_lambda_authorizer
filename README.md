# Lambda Authorizer for OpenID/JWT Tokens and RDS Backend
This lambda authorizer function allows to use JWT Tokens generated by OAuth 2.0
authorization flows within the AWS API Gateway. Permissions to access individual
API functions can be stored within a table on a RDS backend (MariaDB implementation).

## How it Works?
This lambda authorizer expects a Bearer Authorization header containing a JWT Token.
The token must include a `unique_name` claim. The claim is then used to lookup for
permissions in a RDS table.

Token signature is validated against the public certificates exposed by the Well-known
OAuth configuration endpoint and a AWS policy is built "on-the-fly" using the permissions
stored in another RDS table.

To get the JWT Token from the OpenID provider please consult the provider documentation.

## Why?
There are a couple of reasons why you want to use a lambda authorizer like this for an
API Gateway Endpoint:
* Your IAM provider is hosted outside the AWS infrastructure.
* You want to keep your permissions simple without going into the complexities of the AWS role management.
* Your application is fairly simple and you want to have a simple user/permission backend.

Please take into consideration that lambda authorizers come with a computational cost as they
are ran to check every request. However, you can enable cache to reduce a little bit the costs.

## Requirements
To use this lambda layer you must make sure you include the following libraries in a
Python layer:
* cryptography
* PyMySQL
* requests
* PyJWT

You can build each library as a separate layer or just make a big layer with all
the dependencies. You can find examples about how to create the python layers here:

https://github.com/mxgxw/aws_lambda_layers

## Configuration
You can change the configuration using environment variables:
- ***OPENID_CONFIG_URI***: Well-known configuration for the OpenID provider.
- ***APP_CLIENT_ID***: This is the 'audience' used to validate the JWT Tokens.
- ***RDS_INSTANCE_ENDPOINT***: RDS Instance endpoint.
- ***DB_NAME***: RDS Database name.
- ***DB_PASSWORD***: RDS Database password.
- ***DB_USERNAME***: RDS Database username.

To connect to a RDS instance from a lambda you could use RDS Proxys. However
they are not avaiable for all the availability regions and they are in "preview"
status.

To allow this lambda to connect to a RDS backend you'll have to:
1. Configure a VPC with access to your RDS Instance.
2. Provide lambda role permissions to create EC2 network interfaces.
3. Enable NAT* to access the RDS instance.
More info is available here:

https://aws.amazon.com/premiumsupport/knowledge-center/internet-access-lambda-function/

*Please take into consideration that NAT is not covered under the AWS Free-Tier.

## API Gateway Configuration
- Create a new Authorizer with this lambda as a target.
- In **Token Source** write: `Authorizer`
- Mark **Authorization Caching** if you don't want this function to be executed on each request.
    For testing you can disable this.

To enable the lambda authorization for your API calls, after you create a new method.
Click on the "Method Request" configuration and select your Authorizer under the "Authorization" settings.

## RDS Tables
You must create two tables and one view on your RDS backend:

### Tables
users:
- id: Unique id.
- email: This column must match the `unique_name` claim from your token.

users_permissions:
- id: Unique id.
- user_id: Foreign key to the table user.
- method: HTTP Verb (GET/POST/PUT/DELETE)
- path: Path of the API resource.

Remember that you'll have to figure out the path for your API call as this is
automatically generated by the API Gateway when you set-up your resources and
methods.

### Views
Create a view as follows:
```sql
CREATE OR REPLACE
ALGORITHM = UNDEFINED VIEW `my_db`.`all_user_permissions` AS
SELECT
    `my_db`.`users`.`id` AS `id`,
    `my_db`.`users`.`email` AS `email`,
    `my_db`.`users`.`org` AS `org`,
    `my_db`.`user_permissions`.`method` AS `method`,
    `my_db`.`user_permissions`.`path` AS `path`
FROM
    (`my_db`.`user_permissions`
JOIN `my_db`.`users` on
    (`my_db`.`user_permissions`.`user_id` = `my_db`.`users`.`id`))
```

## Testing
Testing can be a little bit tricky:
1. You need to get a valid token from your OpenID provider. Any other token will be rejected as
    the digital signature of the token is always verified.
2. Go to the "Authorizers" section within the API Gateway Console
3. Enter your token as "Bearer ----MY---JWT---TOKEN---"
4. If everything is working you should get a policy with the permissions defined on your tables.

### Testing from the Lambda Console
1. You need to get a valid token from your OpenID provider. Any other token will be rejected as
    the digital signature of the token is always verified.
2. Create a new test event as follow:
```json
{
  "type": "TOKEN",
  "methodArn": "arn:aws:execute-api:eu-central-1:1233342:abcde/ESTestInvoke-stage/GET/",
  "authorizationToken": "Bearer ----MY---JWT---TOKEN---"
}
```
3. If everything is working you should get a policy with the permissions defined on your tables.

## Accessing the Authorization Context within the Lambda functions
1. Enable the *Lambda Proxy Integration* for the functions that use your *Lambda Authorizer*
2. Authorization context will be available under `event["requestContext"]["authorizer"]`
3. The `unique_name` claim will be available under `event["requestContext"]["authorizer"]["principalId"]`

## Copyrights
This code is based on the lambda authorizer example for Python from AWS.
```
Copyrights 2020 Mario GÃ³mez <mxgxw.alpha@gmail.com>
Apache 2.0 License
```
